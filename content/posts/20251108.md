---
title: "Hraal: Project Structure and Tiled Integration"
date: 2025-11-08
draft: false
---

The rebuild begins. After setting up the foundation in the last post, I spent my first real development session getting the project structured and Tiled maps rendering. No more hardcoded level generation - we're doing this properly.

**Project Structure**

I kept it simple to start:
```text
Hraal/
├── Hraal.sln
├── Hraal.Engine/          # Class library - engine code
│   └── Hraal.Engine.csproj
└── Hraal.Game/            # MonoGame project - the actual game
    └── Hraal.Game.csproj
```

The engine is just a .NET class library that references MonoGame as a NuGet package. The game project references the engine and runs the actual application. This separation is critical - it means engine systems stay independent of game logic. When I inevitably need to refactor how rendering works, I'm not touching game code. When I'm prototyping game mechanics, I'm not accidentally breaking core engine systems.

This is the opposite of what I did six years ago, where everything was tangled together in one giant mess.

**The ECS Decision**

I'm planning to use an Entity Component System architecture for this engine, but I'm not starting with it. ECS libraries like Arch or DefaultEcs will come later, once I understand what I actually need from the system.

The old engine had massive lists of game objects with god-knows-how-many properties, most of which any given object didn't even use. ECS flips this - entities are just IDs, components are pure data, and systems operate on entities that have specific component combinations. It's more modular, more performant, and way easier to reason about.

But building the ECS structure before I have anything to put in it would be premature. Right now, I need to see tiles and move a camera. The architecture can wait until I'm actually creating entities that need managing.

**Moving Away from Hardcoded Maps**

The old engine had levels built in classes - procedurally generated chaos that became impossible to debug or iterate on. For the actual game I'm building in this engine, I need handcrafted levels. Specific buildings to rob, specific layouts to learn during your day job so you can navigate them at night. This means Tiled integration was priority one.

**Tiled Integration with MonoGame.Extended**

Getting Tiled working was straightforward:
- Created a test isometric map (68x36 tile size, 10x10 grid)
- Added MonoGame.Extended and MonoGame.Extended.Tiled packages
- Loaded the map through MonoGame's Content Pipeline
- Set up a basic camera with WASD movement

{{< figure src="https://github.com/volyth/volythblog/blob/main/assets/images/newhraal.png?raw=true" caption="First successful Tiled map render" >}}

**What's Next**

Now that maps load and render, the next step is getting entities working - starting with a player character that can actually move around the tile grid. That means implementing proper screen-to-tile coordinate conversion and basic collision detection. Once I have a few different entity types (player, doors, containers), that's when I'll bring in ECS properly.

One step at a time.

<br>
<br>
<br>
<br>
<br>